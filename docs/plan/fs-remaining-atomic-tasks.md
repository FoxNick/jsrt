---
Created: 2025-10-05T23:30:00Z
Last Updated: 2025-10-05T23:30:00Z
Status: üü° PLANNING
Overall Progress: 104/132 APIs (78.8% complete)
Remaining: 28 APIs
---

# Node.js fs Module - Atomic Task Breakdown for Remaining Work

## Executive Summary

**Current Status:**
- ‚úÖ 104/132 APIs implemented (78.8% complete)
- ‚úÖ Phase 0-3 completed (Foundation, Sync, Async, Promise core)
- ‚úÖ Quality metrics: 113/113 tests (100%), 0 memory leaks, 90.6% WPT
- üéØ Remaining: 28 APIs across 3 categories

**Recommended Approach:**
- **Phase A (HIGH PRIORITY)**: 8 high-value APIs ‚Üí 84.8% complete (5-6 hours)
- **Phase B (RECOMMENDED)**: Additional 12 APIs ‚Üí 90.9% complete (14-15 hours total)
- **Phase C (OPTIONAL)**: Additional 4 APIs ‚Üí 93.2% complete (16-17 hours total)
- **Phase D (DEFER)**: Advanced features ‚Üí 100% (40+ hours - not recommended)

**Critical Path Analysis:**
- ‚úÖ NO BLOCKING DEPENDENCIES - All tasks are independent
- ‚úÖ MAXIMUM PARALLELIZATION - Can execute all tasks in parallel within each session
- ‚úÖ PROVEN PATTERNS - All implementation patterns established in existing 104 APIs
- ‚úÖ LOW RISK - Very high confidence in estimates and success

**Key Insight:**
The remaining 21% of APIs account for only ~10% of actual real-world usage. Current 78.8% completion already covers 90%+ of common use cases. Phase A+B targets 90.9% API coverage with maximum value/effort ratio.

---

## Phase A: High-Value APIs (Priority 1)

**Target:** 104 ‚Üí 112 APIs (84.8% complete)
**Effort:** 5-6 hours
**Risk:** VERY LOW
**Value:** HIGHEST
**Parallelization:** 100% - All tasks independent

### Session A1: FileHandle Convenience Methods

**Context:** FileHandle is the modern Promise-based file API. Missing convenience methods force users to manually manage open/close cycles. These are the MOST REQUESTED methods.

#### Task A1.1: FileHandle.appendFile()
**ID:** FH-APPEND-001
**Priority:** CRITICAL ‚≠ê
**Execution Mode:** [P] Parallel
**Dependencies:** None (base FileHandle class exists)
**Risk:** LOW
**Complexity:** MEDIUM

**Description:**
Implement FileHandle.appendFile(data, options) method that appends data to the file associated with the FileHandle.

**Technical Details:**
- Pattern: Use existing FileHandle.write() method in append mode
- Implementation: Multi-step async (fstat to get size ‚Üí write at end)
- Files to modify: src/node/fs/fs_promises.c
- Estimated lines: +80 lines
- Memory: Allocate buffer for string/Buffer conversion, free in callback
- Error handling: Propagate write errors, handle closed FileHandle

**Acceptance Criteria:**
- [ ] Appends string/Buffer/TypedArray data to file
- [ ] Supports encoding option (default: 'utf8')
- [ ] Returns Promise<void>
- [ ] Throws if FileHandle is closed
- [ ] Handles empty data correctly
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: happy path + error cases (at least 3 tests)

**Test Plan:**
```javascript
// test/test_fs_filehandle_append.js
import { open } from 'node:fs/promises';

// Test 1: Basic append
const fh = await open('test.txt', 'w');
await fh.appendFile('line1\n');
await fh.appendFile('line2\n');
await fh.close();
const content = readFileSync('test.txt', 'utf8');
assert(content === 'line1\nline2\n');

// Test 2: Closed FileHandle error
await assert.rejects(fh.appendFile('data'), /closed/);

// Test 3: Buffer append
const fh2 = await open('test2.txt', 'w');
await fh2.appendFile(Buffer.from('binary data'));
await fh2.close();
```

**Estimated Effort:** 1 hour

---

#### Task A1.2: FileHandle.readFile()
**ID:** FH-READ-001
**Priority:** CRITICAL ‚≠ê
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** MEDIUM

**Description:**
Implement FileHandle.readFile(options) method that reads the entire file contents.

**Technical Details:**
- Pattern: fstat to get size ‚Üí allocate buffer ‚Üí read ‚Üí return Buffer/string
- Implementation: Multi-step async (fstat ‚Üí read ‚Üí convert)
- Files to modify: src/node/fs/fs_promises.c
- Estimated lines: +100 lines
- Memory: Allocate buffer matching file size, handle empty files (malloc(0) issue)
- Error handling: Check file size, handle read errors, encoding errors

**Acceptance Criteria:**
- [ ] Reads entire file into Buffer (default)
- [ ] Supports encoding option to return string
- [ ] Returns Promise<Buffer> or Promise<string>
- [ ] Throws if FileHandle is closed
- [ ] Handles empty files correctly (0 bytes)
- [ ] ASAN clean (0 leaks)
- [ ] Cross-platform safe (malloc(0) handling)
- [ ] Test coverage: happy path + edge cases (at least 4 tests)

**Test Plan:**
```javascript
// Test 1: Read as Buffer
const fh = await open('test.txt', 'r');
const buffer = await fh.readFile();
assert(buffer instanceof Buffer);

// Test 2: Read as string
const content = await fh.readFile({ encoding: 'utf8' });
assert(typeof content === 'string');

// Test 3: Empty file
const emptyFh = await open('empty.txt', 'r');
const emptyContent = await emptyFh.readFile();
assert(emptyContent.length === 0);

// Test 4: Closed FileHandle
await fh.close();
await assert.rejects(fh.readFile(), /closed/);
```

**Estimated Effort:** 1 hour

---

#### Task A1.3: FileHandle.writeFile()
**ID:** FH-WRITE-001
**Priority:** CRITICAL ‚≠ê
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** MEDIUM

**Description:**
Implement FileHandle.writeFile(data, options) method that writes data to the file, replacing existing content.

**Technical Details:**
- Pattern: truncate(0) ‚Üí write(data)
- Implementation: Multi-step async (ftruncate ‚Üí write)
- Files to modify: src/node/fs/fs_promises.c
- Estimated lines: +90 lines
- Memory: Allocate buffer for string conversion, free in callback
- Error handling: Handle truncate errors, write errors, encoding errors

**Acceptance Criteria:**
- [ ] Truncates file and writes new content
- [ ] Accepts string/Buffer/TypedArray
- [ ] Supports encoding option (default: 'utf8')
- [ ] Returns Promise<void>
- [ ] Throws if FileHandle is closed
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: happy path + error cases (at least 3 tests)

**Test Plan:**
```javascript
// Test 1: Replace file content
const fh = await open('test.txt', 'w');
await fh.writeFile('initial content');
await fh.writeFile('new content');
await fh.close();
const content = readFileSync('test.txt', 'utf8');
assert(content === 'new content');

// Test 2: Buffer write
const fh2 = await open('test2.txt', 'w');
await fh2.writeFile(Buffer.from('buffer data'));
await fh2.close();

// Test 3: Closed FileHandle
await assert.rejects(fh.writeFile('data'), /closed/);
```

**Estimated Effort:** 1 hour

---

#### Task A1.4: FileHandle.chmod()
**ID:** FH-CHMOD-001
**Priority:** HIGH
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** SIMPLE

**Description:**
Implement FileHandle.chmod(mode) method that changes file permissions.

**Technical Details:**
- Pattern: Direct uv_fs_fchmod() call
- Implementation: Single async operation
- Files to modify: src/node/fs/fs_promises.c
- Estimated lines: +60 lines
- Memory: Simple work request structure
- Error handling: Permission errors, closed FileHandle

**Acceptance Criteria:**
- [ ] Changes file permissions via file descriptor
- [ ] Accepts numeric mode (e.g., 0o644)
- [ ] Returns Promise<void>
- [ ] Throws if FileHandle is closed
- [ ] Cross-platform (Windows limited support)
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: happy path + error case (at least 2 tests)

**Test Plan:**
```javascript
// Test 1: Change permissions
const fh = await open('test.txt', 'w');
await fh.chmod(0o644);
const stats = await fh.stat();
assert((stats.mode & 0o777) === 0o644);

// Test 2: Closed FileHandle
await fh.close();
await assert.rejects(fh.chmod(0o644), /closed/);
```

**Estimated Effort:** 30 minutes

---

### Session A2: Async Callback Low-Level Operations

**Context:** These are low-level file operations that currently only exist in sync form. Adding async versions completes the callback API coverage for file descriptor operations.

#### Task A2.1: fs.truncate(path, len, callback)
**ID:** ASYNC-TRUNC-001
**Priority:** MEDIUM
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** SIMPLE

**Description:**
Implement async callback version of truncate() that truncates a file to specified length.

**Technical Details:**
- Pattern: uv_fs_open() ‚Üí uv_fs_ftruncate() ‚Üí uv_fs_close()
- Implementation: Multi-step async operation
- Files to modify: src/node/fs/fs_async_core.c
- Estimated lines: +80 lines
- Memory: Standard async work request
- Error handling: File not found, permission errors

**Acceptance Criteria:**
- [ ] Truncates file to specified length
- [ ] Callback signature: (err) => void
- [ ] Handles path resolution
- [ ] Extends file with null bytes if len > current size
- [ ] Shrinks file if len < current size
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: shrink, extend, error cases (at least 3 tests)

**Test Plan:**
```javascript
// Test 1: Truncate to smaller size
fs.truncate('test.txt', 10, (err) => {
  assert(!err);
  assert(statSync('test.txt').size === 10);
});

// Test 2: Extend file
fs.truncate('test.txt', 100, (err) => {
  assert(!err);
  assert(statSync('test.txt').size === 100);
});
```

**Estimated Effort:** 30 minutes

---

#### Task A2.2: fs.ftruncate(fd, len, callback)
**ID:** ASYNC-FTRUNC-001
**Priority:** MEDIUM
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** SIMPLE

**Description:**
Implement async callback version of ftruncate() that truncates an open file descriptor.

**Technical Details:**
- Pattern: Direct uv_fs_ftruncate() call
- Implementation: Single async operation
- Files to modify: src/node/fs/fs_async_core.c
- Estimated lines: +60 lines
- Memory: Standard async work request
- Error handling: Invalid fd, permission errors

**Acceptance Criteria:**
- [ ] Truncates file via file descriptor
- [ ] Callback signature: (err) => void
- [ ] Works with open file descriptors
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: happy path + error case (at least 2 tests)

**Test Plan:**
```javascript
// Test 1: Truncate via fd
const fd = fs.openSync('test.txt', 'r+');
fs.ftruncate(fd, 50, (err) => {
  assert(!err);
  assert(fstatSync(fd).size === 50);
  fs.closeSync(fd);
});
```

**Estimated Effort:** 30 minutes

---

#### Task A2.3: fs.fsync(fd, callback)
**ID:** ASYNC-FSYNC-001
**Priority:** MEDIUM
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** SIMPLE

**Description:**
Implement async callback version of fsync() that synchronizes file data to disk.

**Technical Details:**
- Pattern: Direct uv_fs_fsync() call
- Implementation: Single async operation
- Files to modify: src/node/fs/fs_async_core.c
- Estimated lines: +60 lines
- Memory: Standard async work request
- Error handling: Invalid fd

**Acceptance Criteria:**
- [ ] Synchronizes file data and metadata to disk
- [ ] Callback signature: (err) => void
- [ ] Works with open file descriptors
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: happy path + error case (at least 2 tests)

**Test Plan:**
```javascript
// Test 1: Sync file
const fd = fs.openSync('test.txt', 'w');
fs.writeSync(fd, 'data');
fs.fsync(fd, (err) => {
  assert(!err);
  fs.closeSync(fd);
});
```

**Estimated Effort:** 30 minutes

---

#### Task A2.4: fs.fdatasync(fd, callback)
**ID:** ASYNC-FDSYNC-001
**Priority:** MEDIUM
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** SIMPLE

**Description:**
Implement async callback version of fdatasync() that synchronizes file data (not metadata) to disk.

**Technical Details:**
- Pattern: Direct uv_fs_fdatasync() call
- Implementation: Single async operation
- Files to modify: src/node/fs/fs_async_core.c
- Estimated lines: +60 lines
- Memory: Standard async work request
- Error handling: Invalid fd

**Acceptance Criteria:**
- [ ] Synchronizes file data (not metadata) to disk
- [ ] Faster than fsync (doesn't sync metadata)
- [ ] Callback signature: (err) => void
- [ ] Works with open file descriptors
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: happy path + error case (at least 2 tests)

**Test Plan:**
```javascript
// Test 1: Sync file data only
const fd = fs.openSync('test.txt', 'w');
fs.writeSync(fd, 'data');
fs.fdatasync(fd, (err) => {
  assert(!err);
  fs.closeSync(fd);
});
```

**Estimated Effort:** 30 minutes

---

### Phase A Summary

**Total Tasks:** 8 APIs
**Total Effort:** 5-6 hours
**Parallelization:** 100% - All tasks can run simultaneously
**Risk:** VERY LOW - All patterns proven
**Impact:** 104 ‚Üí 112 APIs (84.8% complete)

**Completion Criteria:**
- [ ] All 8 APIs implemented and tested
- [ ] make format && make test && make wpt (all passing)
- [ ] ASAN verification (0 leaks)
- [ ] Update node-fs-plan.md with progress
- [ ] Git commit with clear message

**Testing Strategy:**
- Test each API individually during implementation
- Full regression test suite after all 8 complete
- ASAN run on all new tests
- Cross-platform smoke test (Linux minimum)

---

## Phase B: Medium-Value APIs (Priority 2)

**Target:** 112 ‚Üí 120 APIs (90.9% complete)
**Effort:** 9 additional hours (14-15 hours total from start)
**Risk:** LOW
**Value:** MEDIUM-HIGH
**Parallelization:** 100% - All tasks independent

### Session B1: Promise API Wrappers

**Context:** These Promise APIs wrap existing sync/async implementations. They complete the fsPromises namespace for commonly-used operations.

#### Task B1.1: fsPromises.mkdtemp(prefix, options)
**ID:** PROM-MKDTEMP-001
**Priority:** MEDIUM
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** MEDIUM

**Description:**
Implement Promise version of mkdtemp() that creates a unique temporary directory.

**Technical Details:**
- Pattern: Generate unique suffix ‚Üí uv_fs_mkdir()
- Implementation: Template generation + async mkdir
- Files to modify: src/node/fs/fs_promises.c
- Estimated lines: +90 lines
- Memory: Allocate template string, free in callback
- Error handling: Template validation, mkdir errors

**Acceptance Criteria:**
- [ ] Creates unique temporary directory
- [ ] Accepts prefix string
- [ ] Supports encoding option (default: 'utf8')
- [ ] Returns Promise<string> with created path
- [ ] Uses 6 random characters for uniqueness
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: basic, encoding, error (at least 3 tests)

**Test Plan:**
```javascript
// Test 1: Basic mkdtemp
const dir = await fsPromises.mkdtemp('/tmp/test-');
assert(dir.startsWith('/tmp/test-'));
assert(existsSync(dir));

// Test 2: Multiple calls create unique dirs
const dir1 = await fsPromises.mkdtemp('/tmp/test-');
const dir2 = await fsPromises.mkdtemp('/tmp/test-');
assert(dir1 !== dir2);
```

**Estimated Effort:** 1 hour

---

#### Task B1.2: fsPromises.truncate(path, len)
**ID:** PROM-TRUNC-001
**Priority:** MEDIUM
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** SIMPLE

**Description:**
Implement Promise version of truncate() that truncates a file to specified length.

**Technical Details:**
- Pattern: uv_fs_open() ‚Üí uv_fs_ftruncate() ‚Üí uv_fs_close()
- Implementation: Multi-step async operation
- Files to modify: src/node/fs/fs_promises.c
- Estimated lines: +80 lines
- Memory: Standard promise work request
- Error handling: File not found, permission errors

**Acceptance Criteria:**
- [ ] Truncates file to specified length
- [ ] Returns Promise<void>
- [ ] Handles path resolution
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: shrink, extend, error (at least 3 tests)

**Estimated Effort:** 30 minutes

---

#### Task B1.3: fsPromises.copyFile(src, dest, mode)
**ID:** PROM-COPY-001
**Priority:** MEDIUM
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** MEDIUM

**Description:**
Implement Promise version of copyFile() that copies a file.

**Technical Details:**
- Pattern: Use existing uv_fs_copyfile()
- Implementation: Single async operation with mode flags
- Files to modify: src/node/fs/fs_promises.c
- Estimated lines: +70 lines
- Memory: Standard promise work request
- Error handling: Source not found, destination exists (if COPYFILE_EXCL)

**Acceptance Criteria:**
- [ ] Copies file from src to dest
- [ ] Supports mode flags (COPYFILE_EXCL, etc.)
- [ ] Returns Promise<void>
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: basic, excl flag, error (at least 3 tests)

**Test Plan:**
```javascript
// Test 1: Basic copy
await fsPromises.copyFile('source.txt', 'dest.txt');
assert(existsSync('dest.txt'));

// Test 2: COPYFILE_EXCL
await fsPromises.copyFile('source.txt', 'dest.txt'); // OK
await assert.rejects(
  fsPromises.copyFile('source.txt', 'dest.txt', COPYFILE_EXCL),
  /exists/
);
```

**Estimated Effort:** 1 hour

---

#### Task B1.4: fsPromises.lchmod(path, mode)
**ID:** PROM-LCHMOD-001
**Priority:** LOW
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** SIMPLE

**Description:**
Implement Promise version of lchmod() that changes permissions without following symlinks.

**Technical Details:**
- Pattern: Use existing lchmod() logic with Promise wrapper
- Implementation: Single async operation
- Files to modify: src/node/fs/fs_promises.c
- Estimated lines: +60 lines
- Memory: Standard promise work request
- Error handling: Platform support check (macOS only), permission errors

**Acceptance Criteria:**
- [ ] Changes symlink permissions (macOS only)
- [ ] Returns Promise<void>
- [ ] Throws ENOSYS on unsupported platforms
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: platform check (at least 1 test)

**Estimated Effort:** 45 minutes

---

### Session B2: Async Callback Advanced Operations

**Context:** Complete the async callback API surface with less commonly used operations.

#### Task B2.1: fs.mkdtemp(prefix, options, callback)
**ID:** ASYNC-MKDTEMP-001
**Priority:** MEDIUM
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** MEDIUM

**Description:**
Implement async callback version of mkdtemp() that creates a unique temporary directory.

**Technical Details:**
- Pattern: Same as Promise version but with callback
- Implementation: Template generation + async mkdir
- Files to modify: src/node/fs/fs_async_core.c
- Estimated lines: +90 lines
- Memory: Standard async work request
- Error handling: Template validation, mkdir errors

**Acceptance Criteria:**
- [ ] Creates unique temporary directory
- [ ] Callback signature: (err, folder) => void
- [ ] Returns created path in callback
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: basic, encoding, error (at least 3 tests)

**Estimated Effort:** 1 hour

---

#### Task B2.2: fs.statfs(path, options, callback)
**ID:** ASYNC-STATFS-001
**Priority:** LOW
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** MEDIUM

**Description:**
Implement async callback version of statfs() that returns filesystem statistics.

**Technical Details:**
- Pattern: Use existing uv_fs_statfs() (libuv 1.31+)
- Implementation: Single async operation with result object creation
- Files to modify: src/node/fs/fs_async_core.c
- Estimated lines: +100 lines
- Memory: Standard async work request + stats object
- Error handling: Path not found, unsupported platform

**Acceptance Criteria:**
- [ ] Returns filesystem statistics object
- [ ] Callback signature: (err, stats) => void
- [ ] Stats includes: type, bsize, blocks, bfree, bavail, files, ffree
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: basic, error (at least 2 tests)

**Estimated Effort:** 1 hour

---

### Session B3: FileHandle Vectored I/O

**Context:** Vectored I/O operations (readv/writev) allow reading/writing to multiple buffers in a single syscall. These are advanced operations for performance-critical code.

#### Task B3.1: FileHandle.readv(buffers, position)
**ID:** FH-READV-001
**Priority:** MEDIUM
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** MEDIUM
**Complexity:** MEDIUM

**Description:**
Implement FileHandle.readv() method that reads into multiple buffers in a single operation.

**Technical Details:**
- Pattern: Use existing uv_fs_read() with iov array
- Implementation: Convert JS buffer array ‚Üí uv_buf_t[] ‚Üí async read
- Files to modify: src/node/fs/fs_promises.c
- Estimated lines: +120 lines
- Memory: Allocate uv_buf_t array, manage buffer references
- Error handling: Invalid buffers, closed FileHandle, read errors

**Acceptance Criteria:**
- [ ] Reads into array of Buffer/TypedArray
- [ ] Accepts optional position parameter
- [ ] Returns Promise<{ bytesRead, buffers }>
- [ ] Throws if FileHandle is closed
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: basic, position, multiple buffers (at least 3 tests)

**Test Plan:**
```javascript
// Test 1: Read into multiple buffers
const fh = await open('test.txt', 'r');
const buf1 = Buffer.alloc(10);
const buf2 = Buffer.alloc(10);
const { bytesRead } = await fh.readv([buf1, buf2]);
assert(bytesRead <= 20);

// Test 2: Read with position
const { bytesRead: read2 } = await fh.readv([buf1], 100);
```

**Estimated Effort:** 2 hours

---

#### Task B3.2: FileHandle.writev(buffers, position)
**ID:** FH-WRITEV-001
**Priority:** MEDIUM
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** MEDIUM
**Complexity:** MEDIUM

**Description:**
Implement FileHandle.writev() method that writes from multiple buffers in a single operation.

**Technical Details:**
- Pattern: Use existing uv_fs_write() with iov array
- Implementation: Convert JS buffer array ‚Üí uv_buf_t[] ‚Üí async write
- Files to modify: src/node/fs/fs_promises.c
- Estimated lines: +120 lines
- Memory: Allocate uv_buf_t array, manage buffer references
- Error handling: Invalid buffers, closed FileHandle, write errors

**Acceptance Criteria:**
- [ ] Writes from array of Buffer/TypedArray
- [ ] Accepts optional position parameter
- [ ] Returns Promise<{ bytesWritten, buffers }>
- [ ] Throws if FileHandle is closed
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: basic, position, multiple buffers (at least 3 tests)

**Test Plan:**
```javascript
// Test 1: Write from multiple buffers
const fh = await open('test.txt', 'w');
const buf1 = Buffer.from('hello ');
const buf2 = Buffer.from('world');
const { bytesWritten } = await fh.writev([buf1, buf2]);
assert(bytesWritten === 11);

// Test 2: Write with position
const { bytesWritten: written2 } = await fh.writev([buf1], 100);
```

**Estimated Effort:** 2 hours

---

### Phase B Summary

**Total Tasks:** 8 APIs
**Total Effort:** 9 hours
**Cumulative Effort:** 14-15 hours (from Phase A start)
**Parallelization:** 100% - All tasks can run simultaneously
**Risk:** LOW - Proven patterns, slightly higher complexity for vectored I/O
**Impact:** 112 ‚Üí 120 APIs (90.9% complete)

**Completion Criteria:**
- [ ] All 8 APIs implemented and tested
- [ ] make format && make test && make wpt (all passing)
- [ ] ASAN verification (0 leaks)
- [ ] Update node-fs-plan.md with progress
- [ ] Git commit with clear message

**Testing Strategy:**
- Test each API individually during implementation
- Full regression test suite after all 8 complete
- ASAN run on all new tests
- Performance benchmarks for vectored I/O
- Cross-platform smoke test (Linux minimum)

---

## Phase C: Low-Priority Completeness (Optional)

**Target:** 120 ‚Üí 123 APIs (93.2% complete)
**Effort:** 2 additional hours (16-17 hours total from start)
**Risk:** VERY LOW
**Value:** LOW (nice-to-have)
**Parallelization:** 100% - All tasks independent

### Session C1: FileHandle Low-Priority Methods

**Context:** These are rarely-used FileHandle methods that provide completeness for professional polish. Not critical for production use.

#### Task C1.1: FileHandle.sync()
**ID:** FH-SYNC-001
**Priority:** LOW
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** SIMPLE

**Description:**
Implement FileHandle.sync() method that synchronizes file data and metadata to disk.

**Technical Details:**
- Pattern: Direct uv_fs_fsync() call
- Implementation: Single async operation
- Files to modify: src/node/fs/fs_promises.c
- Estimated lines: +60 lines
- Memory: Standard promise work request
- Error handling: Closed FileHandle

**Acceptance Criteria:**
- [ ] Synchronizes file data and metadata to disk
- [ ] Returns Promise<void>
- [ ] Throws if FileHandle is closed
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: happy path + error (at least 2 tests)

**Estimated Effort:** 30 minutes

---

#### Task C1.2: FileHandle.datasync()
**ID:** FH-DATASYNC-001
**Priority:** LOW
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** SIMPLE

**Description:**
Implement FileHandle.datasync() method that synchronizes file data (not metadata) to disk.

**Technical Details:**
- Pattern: Direct uv_fs_fdatasync() call
- Implementation: Single async operation
- Files to modify: src/node/fs/fs_promises.c
- Estimated lines: +60 lines
- Memory: Standard promise work request
- Error handling: Closed FileHandle

**Acceptance Criteria:**
- [ ] Synchronizes file data (not metadata) to disk
- [ ] Faster than sync() (doesn't sync metadata)
- [ ] Returns Promise<void>
- [ ] Throws if FileHandle is closed
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: happy path + error (at least 2 tests)

**Estimated Effort:** 30 minutes

---

#### Task C1.3: FileHandle.utimes(atime, mtime)
**ID:** FH-UTIMES-001
**Priority:** LOW
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** SIMPLE

**Description:**
Implement FileHandle.utimes() method that changes file access and modification times.

**Technical Details:**
- Pattern: Direct uv_fs_futime() call
- Implementation: Single async operation
- Files to modify: src/node/fs/fs_promises.c
- Estimated lines: +70 lines
- Memory: Standard promise work request
- Error handling: Time conversion, closed FileHandle

**Acceptance Criteria:**
- [ ] Changes file access and modification times via fd
- [ ] Accepts Date objects or numeric timestamps
- [ ] Returns Promise<void>
- [ ] Throws if FileHandle is closed
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: happy path + error (at least 2 tests)

**Estimated Effort:** 30 minutes

---

#### Task C1.4: FileHandle[Symbol.asyncDispose]()
**ID:** FH-DISPOSE-001
**Priority:** LOW
**Execution Mode:** [P] Parallel
**Dependencies:** None
**Risk:** LOW
**Complexity:** SIMPLE

**Description:**
Implement FileHandle async disposal for ECMAScript explicit resource management (using statement).

**Technical Details:**
- Pattern: Alias to close() method
- Implementation: Symbol property definition
- Files to modify: src/node/fs/fs_promises.c
- Estimated lines: +20 lines
- Memory: None (reuses close())
- Error handling: Same as close()

**Acceptance Criteria:**
- [ ] FileHandle works with `await using` statement
- [ ] Automatically closes on scope exit
- [ ] Returns Promise<void>
- [ ] ASAN clean (0 leaks)
- [ ] Test coverage: using statement (at least 1 test)

**Test Plan:**
```javascript
// Test 1: Explicit resource management
await using fh = await open('test.txt', 'r');
const content = await fh.readFile();
// fh automatically closed when exiting scope
```

**Estimated Effort:** 15 minutes

---

### Phase C Summary

**Total Tasks:** 4 APIs
**Total Effort:** 2 hours
**Cumulative Effort:** 16-17 hours (from Phase A start)
**Parallelization:** 100% - All tasks can run simultaneously
**Risk:** VERY LOW - Trivial implementations
**Impact:** 120 ‚Üí 123 APIs (93.2% complete)

**Completion Criteria:**
- [ ] All 4 APIs implemented and tested
- [ ] make format && make test && make wpt (all passing)
- [ ] ASAN verification (0 leaks)
- [ ] Update node-fs-plan.md with progress
- [ ] Git commit with clear message

---

## Phase D: Advanced Features (DEFERRED)

**Target:** 123 ‚Üí 132 APIs (100% complete)
**Effort:** 40+ hours
**Risk:** MEDIUM
**Value:** VERY LOW
**Recommendation:** ‚ùå DO NOT IMPLEMENT NOW - Wait for user demand

### Deferred Tasks

#### D1: globSync(pattern, options) - 8-12 hours
- **Why defer:** Node.js 22+ bleeding-edge feature, complex glob pattern matching
- **Complexity:** HIGH - Requires glob pattern parser and matcher
- **Alternative:** Users can use existing readdir + manual filtering

#### D2: fsPromises.glob(pattern, options) - 8-12 hours
- **Why defer:** Same as globSync, plus async iteration
- **Complexity:** HIGH - Requires async generator implementation
- **Alternative:** Users can use existing readdir + manual filtering

#### D3: fsPromises.watch(filename, options) - 8-12 hours
- **Why defer:** Complex file watching, FSWatcher integration
- **Complexity:** HIGH - Requires libuv fs_event integration
- **Alternative:** Users can poll with stat()

#### D4: fsPromises.opendir(path, options) - 4-6 hours
- **Why defer:** Async Dir class with iterator
- **Complexity:** MEDIUM - Requires async iterator protocol
- **Alternative:** Use existing readdir()

#### D5: FileHandle.createReadStream(options) - 8 hours
- **Why defer:** Stream integration complexity
- **Complexity:** HIGH - Requires ReadableStream implementation
- **Alternative:** Use readFile() or manual read() loops

#### D6: FileHandle.createWriteStream(options) - 8 hours
- **Why defer:** Stream integration complexity
- **Complexity:** HIGH - Requires WritableStream implementation
- **Alternative:** Use writeFile() or manual write() loops

#### D7: FileHandle.readLines(options) - 4 hours
- **Why defer:** Async line iterator
- **Complexity:** MEDIUM - Requires async iterator + line splitting
- **Alternative:** Use readFile() + manual split('\n')

#### D8: FileHandle.readableWebStream(options) - 8 hours
- **Why defer:** Web Streams API integration
- **Complexity:** HIGH - Requires ReadableStream web API
- **Alternative:** Use readFile()

### Phase D Summary

**Total Tasks:** 8 APIs
**Total Effort:** 40+ hours (3-4 weeks)
**Value:** VERY LOW (rarely used, bleeding-edge features)
**Recommendation:** DEFER until user demand

**Rationale:**
- These features account for <5% of real-world usage
- High implementation complexity vs low user benefit
- Better to wait for actual user requests
- Can implement on-demand if needed

---

## Dependency Graph

```
ALL REMAINING TASKS ARE INDEPENDENT - NO BLOCKING DEPENDENCIES

Session A1 (FileHandle Essentials)
‚îú‚îÄ‚îÄ A1.1 appendFile  ‚îÄ‚îÄ‚îê
‚îú‚îÄ‚îÄ A1.2 readFile     ‚îú‚îÄ‚îÄ All parallel, no dependencies
‚îú‚îÄ‚îÄ A1.3 writeFile    ‚îÇ
‚îî‚îÄ‚îÄ A1.4 chmod        ‚îò

Session A2 (Async Callbacks Basic)
‚îú‚îÄ‚îÄ A2.1 truncate     ‚îê
‚îú‚îÄ‚îÄ A2.2 ftruncate    ‚îú‚îÄ‚îÄ All parallel, no dependencies
‚îú‚îÄ‚îÄ A2.3 fsync        ‚îÇ
‚îî‚îÄ‚îÄ A2.4 fdatasync    ‚îò

Session B1 (Promise Wrappers)
‚îú‚îÄ‚îÄ B1.1 mkdtemp      ‚îê
‚îú‚îÄ‚îÄ B1.2 truncate     ‚îú‚îÄ‚îÄ All parallel, no dependencies
‚îú‚îÄ‚îÄ B1.3 copyFile     ‚îÇ
‚îî‚îÄ‚îÄ B1.4 lchmod       ‚îò

Session B2 (Async Advanced)
‚îú‚îÄ‚îÄ B2.1 mkdtemp      ‚îê
‚îî‚îÄ‚îÄ B2.2 statfs       ‚îò‚îÄ‚îÄ Both parallel, no dependencies

Session B3 (Vectored I/O)
‚îú‚îÄ‚îÄ B3.1 readv        ‚îê
‚îî‚îÄ‚îÄ B3.2 writev       ‚îò‚îÄ‚îÄ Both parallel, no dependencies

Session C1 (Low-Priority)
‚îú‚îÄ‚îÄ C1.1 sync         ‚îê
‚îú‚îÄ‚îÄ C1.2 datasync     ‚îú‚îÄ‚îÄ All parallel, no dependencies
‚îú‚îÄ‚îÄ C1.3 utimes       ‚îÇ
‚îî‚îÄ‚îÄ C1.4 asyncDispose ‚îò

CRITICAL PATH: NONE (all independent)
BLOCKING TASKS: NONE
MAXIMUM PARALLELISM: 100%
```

---

## Parallel Execution Plan

### Maximum Parallelization Strategy

**Key Insight:** Since all remaining tasks are independent, we can execute multiple tasks simultaneously to minimize wall-clock time.

#### Optimistic Timeline (Parallel Execution)

```
Week 1: Phase A + Phase B
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Day 1  ‚îÇ A1.1-A1.4 (4 tasks parallel)    ‚îÇ 1 hour          ‚îÇ
‚îÇ Day 2  ‚îÇ A2.1-A2.4 (4 tasks parallel)    ‚îÇ 1 hour          ‚îÇ
‚îÇ Day 3  ‚îÇ B1.1-B1.4 (4 tasks parallel)    ‚îÇ 1 hour          ‚îÇ
‚îÇ Day 4  ‚îÇ B2.1-B2.2 (2 tasks parallel)    ‚îÇ 1 hour          ‚îÇ
‚îÇ Day 5  ‚îÇ B3.1-B3.2 (2 tasks parallel)    ‚îÇ 2 hours         ‚îÇ
‚îÇ        ‚îÇ Testing & Integration           ‚îÇ 3 hours         ‚îÇ
‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
‚îÇ TOTAL: 9 hours development + 3 hours testing = 12 hours    ‚îÇ
‚îÇ RESULT: 104 ‚Üí 120 APIs (90.9% complete) ‚úÖ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Week 2 (Optional): Phase C + Polish
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Day 6  ‚îÇ C1.1-C1.4 (4 tasks parallel)    ‚îÇ 30 min          ‚îÇ
‚îÇ Day 7  ‚îÇ Final testing & documentation   ‚îÇ 2 hours         ‚îÇ
‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
‚îÇ TOTAL: 2.5 hours                                            ‚îÇ
‚îÇ RESULT: 120 ‚Üí 123 APIs (93.2% complete) ‚úÖ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### Conservative Timeline (Sequential Execution)

```
Week 1-2: Phase A + Phase B
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Week 1 ‚îÇ Phase A (8 APIs sequential)     ‚îÇ 5-6 hours       ‚îÇ
‚îÇ        ‚îÇ Testing                         ‚îÇ 2 hours         ‚îÇ
‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
‚îÇ Week 2 ‚îÇ Phase B (8 APIs sequential)     ‚îÇ 9 hours         ‚îÇ
‚îÇ        ‚îÇ Testing                         ‚îÇ 3 hours         ‚îÇ
‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
‚îÇ TOTAL: 19-20 hours over 2 weeks                             ‚îÇ
‚îÇ RESULT: 104 ‚Üí 120 APIs (90.9% complete) ‚úÖ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Testing Strategy

### Per-API Testing Checklist

For each implemented API:

```
1. Unit Tests (MANDATORY)
   ‚îú‚îÄ‚îÄ [ ] Happy path test (normal usage)
   ‚îú‚îÄ‚îÄ [ ] Error case test #1 (invalid arguments)
   ‚îú‚îÄ‚îÄ [ ] Error case test #2 (file not found / permission denied)
   ‚îú‚îÄ‚îÄ [ ] Edge case test (empty file, large file, special chars)
   ‚îî‚îÄ‚îÄ [ ] Cleanup verification (no temp files, no leaked fds)

2. Quality Gates (MANDATORY)
   ‚îú‚îÄ‚îÄ [ ] make format (code formatting)
   ‚îú‚îÄ‚îÄ [ ] make test (100% pass rate)
   ‚îú‚îÄ‚îÄ [ ] make wpt (‚â•90.6% baseline)
   ‚îî‚îÄ‚îÄ [ ] ASAN check: ./target/debug/jsrt_m test/test_fs_*.js

3. Documentation
   ‚îú‚îÄ‚îÄ [ ] Inline comments for complex logic
   ‚îú‚îÄ‚îÄ [ ] JSDoc comment for API signature
   ‚îî‚îÄ‚îÄ [ ] Update node-fs-plan.md progress
```

### Phase-Level Testing

After each phase completion:

```
1. Regression Testing
   ‚îú‚îÄ‚îÄ [ ] All existing tests still pass (113/113 baseline)
   ‚îú‚îÄ‚îÄ [ ] New tests added and passing
   ‚îî‚îÄ‚îÄ [ ] No test timeouts or hangs

2. Memory Safety
   ‚îú‚îÄ‚îÄ [ ] ASAN clean (0 leaks, 0 use-after-free)
   ‚îú‚îÄ‚îÄ [ ] Valgrind clean (if available)
   ‚îî‚îÄ‚îÄ [ ] File descriptor accounting (no leaks)

3. Cross-Platform
   ‚îú‚îÄ‚îÄ [ ] Linux smoke test (minimum)
   ‚îú‚îÄ‚îÄ [ ] macOS test (if available)
   ‚îî‚îÄ‚îÄ [ ] Windows/WSL test (if available)

4. Performance
   ‚îú‚îÄ‚îÄ [ ] No significant regression vs baseline
   ‚îú‚îÄ‚îÄ [ ] Async operations are non-blocking
   ‚îî‚îÄ‚îÄ [ ] Memory usage within expected bounds
```

### Integration Testing

After all phases complete:

```
1. End-to-End Scenarios
   ‚îú‚îÄ‚îÄ [ ] Full file lifecycle (create, read, write, delete)
   ‚îú‚îÄ‚îÄ [ ] Concurrent operations (multiple files, multiple ops)
   ‚îú‚îÄ‚îÄ [ ] Error recovery (handle failures gracefully)
   ‚îî‚îÄ‚îÄ [ ] Resource cleanup (all fds closed, all memory freed)

2. Stress Testing
   ‚îú‚îÄ‚îÄ [ ] Large file operations (>1GB)
   ‚îú‚îÄ‚îÄ [ ] Many small file operations (1000+ files)
   ‚îú‚îÄ‚îÄ [ ] Concurrent async operations (100+ simultaneous)
   ‚îî‚îÄ‚îÄ [ ] Error injection (simulate disk full, permission errors)

3. Compatibility Testing
   ‚îú‚îÄ‚îÄ [ ] Node.js fs compatibility smoke test
   ‚îú‚îÄ‚îÄ [ ] WPT File API tests (if applicable)
   ‚îî‚îÄ‚îÄ [ ] Real-world usage patterns
```

---

## Risk Assessment & Mitigation

### Technical Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| **Implementation bugs** | VERY LOW | LOW | ‚Ä¢ All patterns proven in 104 existing APIs<br>‚Ä¢ Incremental testing after each API<br>‚Ä¢ Code review before commit |
| **Memory leaks** | VERY LOW | HIGH | ‚Ä¢ ASAN testing mandatory for all new code<br>‚Ä¢ Existing code is ASAN clean<br>‚Ä¢ Clear cleanup patterns established |
| **Test failures** | VERY LOW | MEDIUM | ‚Ä¢ 113 tests currently passing<br>‚Ä¢ Test after each API<br>‚Ä¢ Minimal changes to existing code |
| **Platform issues** | LOW | MEDIUM | ‚Ä¢ Cross-platform patterns established<br>‚Ä¢ Platform-specific tests<br>‚Ä¢ Graceful degradation where needed |
| **Performance regression** | VERY LOW | LOW | ‚Ä¢ Async operations use proven libuv patterns<br>‚Ä¢ Performance benchmarks<br>‚Ä¢ No changes to hot paths |

### Schedule Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| **Underestimated effort** | LOW | MEDIUM | ‚Ä¢ Conservative estimates (2x buffer)<br>‚Ä¢ Simple tasks prioritized first<br>‚Ä¢ Can adjust scope if needed |
| **Testing bottleneck** | VERY LOW | LOW | ‚Ä¢ Automated test suite exists<br>‚Ä¢ Fast feedback (~30s per run)<br>‚Ä¢ Incremental testing approach |
| **Blocked dependencies** | NONE | N/A | ‚Ä¢ All tasks are independent<br>‚Ä¢ No critical path blockers |
| **Scope creep** | VERY LOW | LOW | ‚Ä¢ Clear scope defined<br>‚Ä¢ Phase D explicitly deferred<br>‚Ä¢ No new features beyond Node.js API |

### Overall Risk Profile

```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                ‚ïë
‚ïë  Overall Risk Level: VERY LOW ‚úÖ                              ‚ïë
‚ïë  Confidence in Success: VERY HIGH ‚úÖ                          ‚ïë
‚ïë                                                                ‚ïë
‚ïë  Key Success Factors:                                          ‚ïë
‚ïë  ‚îú‚îÄ‚îÄ ‚úÖ All patterns proven in existing 104 APIs              ‚ïë
‚ïë  ‚îú‚îÄ‚îÄ ‚úÖ No blocking dependencies                              ‚ïë
‚ïë  ‚îú‚îÄ‚îÄ ‚úÖ Conservative estimates with buffer                    ‚ïë
‚ïë  ‚îú‚îÄ‚îÄ ‚úÖ Incremental testing and validation                    ‚ïë
‚ïë  ‚îú‚îÄ‚îÄ ‚úÖ Clear acceptance criteria                             ‚ïë
‚ïë  ‚îî‚îÄ‚îÄ ‚úÖ Excellent baseline quality (100% tests, 0 leaks)      ‚ïë
‚ïë                                                                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

---

## Success Metrics

### Quantitative Metrics

**API Coverage Targets:**
```
Current:  104/132 APIs (78.8%) ‚úÖ
Phase A:  112/132 APIs (84.8%) üéØ
Phase B:  120/132 APIs (90.9%) üéØ RECOMMENDED
Phase C:  123/132 APIs (93.2%) üéØ OPTIONAL
Phase D:  132/132 APIs (100%)  ‚ùå DEFERRED
```

**Quality Metrics (MUST MAINTAIN):**
```
Test Pass Rate:    100% (113/113 tests) ‚úÖ MANDATORY
WPT Pass Rate:     ‚â•90.6% (29/32 tests) ‚úÖ MANDATORY
Memory Leaks:      0 leaks (ASAN)       ‚úÖ MANDATORY
Platform Support:  Linux (100%)         ‚úÖ MANDATORY
                   macOS (90%+)         üéØ TARGET
                   Windows (85%+)       üéØ TARGET
```

**Performance Targets:**
```
Async Operations:  Non-blocking (libuv)      ‚úÖ
Memory Overhead:   <2MB for typical workload üéØ
Throughput:        Within 20% of Node.js    üéØ
```

### Qualitative Metrics

**Code Quality:**
- [ ] All code follows jsrt style guide
- [ ] Files <500 lines (refactor if exceeded)
- [ ] Clear error messages matching Node.js format
- [ ] Comprehensive inline documentation
- [ ] No compiler warnings (-Wall -Wextra)

**User Experience:**
- [ ] API signatures match Node.js exactly
- [ ] Error messages are helpful and actionable
- [ ] Edge cases handled gracefully
- [ ] Cross-platform behavior documented

**Maintainability:**
- [ ] Code organization is logical and clear
- [ ] Reusable patterns extracted to common functions
- [ ] Git history is clean with meaningful commits
- [ ] Documentation is up-to-date

---

## Implementation Guidelines

### Development Workflow

```bash
# For each API task:

1. Review task specification
   ‚îú‚îÄ‚îÄ Read task details in this document
   ‚îú‚îÄ‚îÄ Review Node.js documentation
   ‚îî‚îÄ‚îÄ Study existing similar implementations

2. Implement the API
   ‚îú‚îÄ‚îÄ Create/modify source file
   ‚îú‚îÄ‚îÄ Follow established patterns
   ‚îú‚îÄ‚îÄ Add inline comments
   ‚îî‚îÄ‚îÄ Handle all error cases

3. Create tests
   ‚îú‚îÄ‚îÄ Write at least 3 test cases
   ‚îú‚îÄ‚îÄ Cover happy path + error cases
   ‚îî‚îÄ‚îÄ Add to appropriate test file

4. Run quality gates (MANDATORY)
   ‚îú‚îÄ‚îÄ make format
   ‚îú‚îÄ‚îÄ make test (must show 100%)
   ‚îú‚îÄ‚îÄ make wpt (must maintain ‚â•90.6%)
   ‚îî‚îÄ‚îÄ ./target/debug/jsrt_m test/test_fs_*.js (ASAN)

5. Review and commit
   ‚îú‚îÄ‚îÄ Self-review code changes
   ‚îú‚îÄ‚îÄ Update node-fs-plan.md
   ‚îú‚îÄ‚îÄ git add . && git commit -m "feat(fs): add [API name]"
   ‚îî‚îÄ‚îÄ Mark task complete in this document
```

### Code Patterns to Follow

**Promise API Pattern:**
```c
// 1. Create promise work structure
fs_promise_work_t* work = malloc(sizeof(fs_promise_work_t));
work->ctx = ctx;
work->resolve = JS_DupValue(ctx, resolving_funcs[0]);
work->reject = JS_DupValue(ctx, resolving_funcs[1]);
work->path = strdup(path_cstr);

// 2. Start libuv operation
uv_fs_<operation>(fs_get_uv_loop(ctx), &work->req,
                  args..., fs_promise_complete_<type>);

// 3. Return promise immediately
return promise;
```

**Async Callback Pattern:**
```c
// 1. Create async work structure
fs_async_work_t* work = create_async_work(ctx, callback);
work->path = strdup(path_cstr);

// 2. Start libuv operation
uv_fs_<operation>(fs_get_uv_loop(ctx), &work->req,
                  args..., fs_async_complete_<type>);

// 3. Return undefined immediately
return JS_UNDEFINED;
```

**FileHandle Method Pattern:**
```c
// 1. Get FileHandle from this
FileHandle* fh = JS_GetOpaque2(ctx, this_val, filehandle_class_id);
if (!fh) return JS_EXCEPTION;

// 2. Check if closed
if (fh->closed) {
  return JS_ThrowTypeError(ctx, "FileHandle is closed");
}

// 3. Perform operation using fh->fd
// ... (use Promise pattern above)
```

### Memory Management Rules

```c
// MANDATORY: Every malloc must have corresponding free

// QuickJS values
JSValue val = JS_NewString(ctx, "text");
// ... use val
JS_FreeValue(ctx, val);  // MUST free

// C strings from JS
const char* str = JS_ToCString(ctx, argv[0]);
if (!str) return JS_EXCEPTION;
// ... use str
JS_FreeCString(ctx, str);  // MUST free

// Allocated memory
char* buf = malloc(size);
if (!buf) return JS_ThrowOutOfMemory(ctx);
// ... use buf
free(buf);  // MUST free

// Work structures
fs_promise_work_t* work = malloc(sizeof(*work));
// ... use work
fs_promise_work_free(work);  // MUST free (handles all internal frees)
```

### Error Handling Pattern

```c
// Always use create_fs_error for consistency
if (req->result < 0) {
  int err = -req->result;
  JSValue error = create_fs_error(ctx, err, "operation", path);
  JSValue ret = JS_Call(ctx, work->reject, JS_UNDEFINED, 1, &error);
  JS_FreeValue(ctx, error);
  JS_FreeValue(ctx, ret);
  fs_promise_work_free(work);
  return;
}
```

---

## Recommended Next Steps

### Immediate Actions (Today)

1. **Review this task breakdown**
   - [ ] Read through all Phase A tasks
   - [ ] Understand acceptance criteria
   - [ ] Review code patterns

2. **Set up tracking**
   - [ ] Update node-fs-plan.md with Phase A tasks
   - [ ] Create TodoWrite list if desired
   - [ ] Set target completion date

3. **Begin Phase A implementation**
   - [ ] Start with Task A1.1 (FileHandle.appendFile)
   - [ ] Follow development workflow
   - [ ] Test after each API

### Week 1 Goals (Phase A)

```
Day 1-2: FileHandle Essentials (Session A1)
‚îú‚îÄ‚îÄ Implement A1.1-A1.4 (4 APIs)
‚îú‚îÄ‚îÄ Test each API individually
‚îî‚îÄ‚îÄ Commit after each completion

Day 3-4: Async Callbacks Basic (Session A2)
‚îú‚îÄ‚îÄ Implement A2.1-A2.4 (4 APIs)
‚îú‚îÄ‚îÄ Test each API individually
‚îî‚îÄ‚îÄ Commit after each completion

Day 5: Testing & Integration
‚îú‚îÄ‚îÄ Full regression test suite
‚îú‚îÄ‚îÄ ASAN verification
‚îú‚îÄ‚îÄ Update documentation
‚îî‚îÄ‚îÄ Final Phase A commit

Result: 104 ‚Üí 112 APIs (84.8% complete) ‚úÖ
```

### Week 2 Goals (Phase B - Optional)

```
Day 6-7: Promise Wrappers + Async Advanced (Sessions B1+B2)
‚îú‚îÄ‚îÄ Implement B1.1-B1.4 (4 APIs)
‚îú‚îÄ‚îÄ Implement B2.1-B2.2 (2 APIs)
‚îî‚îÄ‚îÄ Test and commit

Day 8-9: Vectored I/O (Session B3)
‚îú‚îÄ‚îÄ Implement B3.1-B3.2 (2 APIs)
‚îú‚îÄ‚îÄ Test with multiple buffer scenarios
‚îî‚îÄ‚îÄ Performance verification

Day 10: Testing & Integration
‚îú‚îÄ‚îÄ Full regression test suite
‚îú‚îÄ‚îÄ ASAN verification
‚îú‚îÄ‚îÄ Performance benchmarks
‚îî‚îÄ‚îÄ Final Phase B commit

Result: 112 ‚Üí 120 APIs (90.9% complete) ‚úÖ PRODUCTION READY
```

---

## Conclusion

### Current Achievement: EXCELLENT ‚úÖ

```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                ‚ïë
‚ïë  üéâ 78.8% Complete (104/132 APIs)                             ‚ïë
‚ïë                                                                ‚ïë
‚ïë  ‚úÖ Phase 0-3 Complete (Foundation, Sync, Async, Promises)    ‚ïë
‚ïë  ‚úÖ 113/113 Tests Passing (100%)                              ‚ïë
‚ïë  ‚úÖ 0 Memory Leaks (ASAN Verified)                            ‚ïë
‚ïë  ‚úÖ 90.6% WPT Pass Rate                                       ‚ïë
‚ïë  ‚úÖ Production-Ready Quality                                  ‚ïë
‚ïë                                                                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

### Recommended Path: Phase A + B (90.9% Target)

```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                ‚ïë
‚ïë  ‚úÖ RECOMMENDED: Implement Phase A + B                        ‚ïë
‚ïë                                                                ‚ïë
‚ïë  Effort:    14-15 hours (1-2 weeks)                           ‚ïë
‚ïë  Risk:      VERY LOW                                          ‚ïë
‚ïë  Value:     HIGH                                              ‚ïë
‚ïë  Result:    120/132 APIs (90.9% complete)                     ‚ïë
‚ïë                                                                ‚ïë
‚ïë  Why this is optimal:                                          ‚ïë
‚ïë  ‚îú‚îÄ‚îÄ ‚úÖ Covers all commonly-used APIs (90%+ real usage)       ‚ïë
‚ïë  ‚îú‚îÄ‚îÄ ‚úÖ Low risk (all patterns proven)                        ‚ïë
‚ïë  ‚îú‚îÄ‚îÄ ‚úÖ Reasonable effort (2 weeks part-time)                 ‚ïë
‚ïë  ‚îú‚îÄ‚îÄ ‚úÖ Production-ready at completion                        ‚ïë
‚ïë  ‚îú‚îÄ‚îÄ ‚úÖ Maximum parallelization (no blockers)                 ‚ïë
‚ïë  ‚îî‚îÄ‚îÄ ‚úÖ Immediate value for users                             ‚ïë
‚ïë                                                                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

### Key Success Factors

1. **Proven Patterns** - All implementation patterns established in existing 104 APIs
2. **No Dependencies** - All remaining tasks are independent (maximum parallelism)
3. **Low Risk** - Very high confidence in estimates and success
4. **High Value** - Phase A+B covers 90%+ of real-world usage
5. **Quality First** - Maintain 100% test pass rate, 0 leaks throughout

### What Makes This Achievable

- ‚úÖ Strong foundation (104 APIs implemented, tested, production-ready)
- ‚úÖ Clear patterns (Promise, async callback, FileHandle all proven)
- ‚úÖ Excellent test coverage (113 tests, ASAN clean)
- ‚úÖ Independent tasks (can parallelize within sessions)
- ‚úÖ Conservative estimates (2x buffer built in)

---

**Document Version:** 1.0
**Created:** 2025-10-05T23:30:00Z
**Status:** Ready for implementation
**Recommended Start:** Phase A, Task A1.1 (FileHandle.appendFile)
**Target Completion:** Phase A+B in 1-2 weeks (90.9% coverage)

---

*This task breakdown provides atomic, executable specifications for all remaining work. Each task includes clear acceptance criteria, test plans, effort estimates, and risk assessment. All tasks are independent with no blocking dependencies, enabling maximum parallelization.*
